/*那其实思路很简单，我们可以将画出这个方阵看成四步完成

1.横向1234停止，然后向下

2.向下567，然后向左

3.左8，9，10然后向上

4.上去11 12然后向右（是不是跟第一步是一样的呀）

所以简单就知道要1.递推

画出这个表显然需要2.二维数组

利用这两个工具，我们不妨设一个数组b[20][20](可以再大点)

利用while函数判断

1.越界了吗？（1234到4就得停）

2.下一个数被填了没有（比如第三步12后面的1就被填了，需要判定）

那只要满足这些条件，就可以把1234....的值分别赋到相应的位置；

则此题得解

代码如下：*/
//特殊矩阵1-回型矩阵
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a,y=0,k=1,x=1;//a代表我们输入的数，x是行，y是列
	int b[100][100];
	scanf("%d",&a);
	while(k<=a*a)//其实只起到一个退出的作用 
	{
		while(y<a&&!b[x][y+1])//1.越界判定变量,2.判断下一个位置有没有有填了的数;
			b[x][++y]=k++;//k++好好体会！！ 第一步 ；++y，y值一开始是0，判断未触界后立马+1
						// 当y=3判定时，执行完后y=4退出 
		while(x<a&&!b[x+1][y])//此时的y已经确定在最后一排了
			b[++x][y]=k++;//第二步 
						//同理，x为什么一开始为1，第二步后面判定成功后要直接下一位，故初始值为1； 
		while(y>1&&!b[x][y-1]) 
			b[x][--y]=k++;//第三步
		while(x>1&&!b[x-1][y])
			b[--x][y]=k++; //第四步 
	} 
	for(int i=1;i<=a;i++)
	{
		for(int j=1;j<=a;j++)
			{
			printf("%d ",b[i][j]);
		}
		printf("\n"); 
	}
	return 0;	
} 

